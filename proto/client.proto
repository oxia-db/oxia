syntax = "proto3";

option go_package = "github.com/streamnative/oxia/proto";
option java_multiple_files = true;

package proto;

service OxiaClient {
  // The client should connect to a single random server which will stream the
  // assignments for all shards on all servers.
  // The first `ShardAssignmentResponse` returned will be the complete set of assignments
  // subsequent sends of the stream will be shard updates.
  rpc ShardAssignments(ShardAssignmentRequest) returns (stream ShardAssignmentResponse);

  // Batched put/delete/get request.
  // The client should send this request to the shard leader.
  // In the future, this may be handled server-side in a proxy layer.
  rpc Batch(BatchRequest) returns (BatchResponse);

  // Receive notifications about all changes to keys in a shard.
  // The client should send this request to the shard leader.
  // In the future, this may be handled server-side in a proxy layer.
  // TODO The client will need to maintain a stream for all shards!!
  rpc Notifications(NotificationRequest) returns (stream NotificationResponse) {}
}

message ShardAssignmentRequest {
  // Placeholder empty message
  // `namespace` may be added here
}

// A shard contains all the keys for which hash falls between its hash range.
// The hash-ranges of all the shards are contiguous, forming a hash-ring around an int32.
// The `shard_id` is the minimum hash that the shard can contain.
message ShardAssignmentResponse {
  repeated ShardAssignment assignment = 1;
}

message ShardAssignment {
  // For hash based sharding, this will contain the 2 32bit hash (min and max) bounds.
  fixed64 shard_id = 1;
  string leader = 2;
}

// Requests are processed in positional order within batches
// and the batch types are processed in the following order:
// put, delete, range_delete, get, range_get.
message BatchRequest {
  // shard_id optional to support server-side hashing and proxy in the future
  optional fixed64 shard_id = 1;
  repeated PutRequest put = 2;
  repeated DeleteRequest delete = 3;
  repeated GetRequest get = 4;
  repeated RangeDeleteRequest range_delete = 5;
  repeated RangeGetRequest range_get = 6;
}

message BatchResponse {
  // The server must guarantee the ordering respects the original ordering from the requests
  repeated PutResponse put = 1;
  repeated DeleteResponse delete = 2;
  repeated GetResponse get = 3;
  repeated RangeDeleteResponse range_delete = 4;
  repeated RangeGetResponse range_get = 5;
}

message PutRequest {
  string key = 1;
  bytes payload = 2;
  optional int64 expected_version = 3;
}

message DeleteRequest {
  string key = 1;
  optional int64 expected_version = 2;
}

message GetRequest {
  string key = 1;
  bool include_payload = 2;
}

message RangeDeleteRequest {
  string start_inclusive = 1;
  string end_exclusive = 2;
}

message RangeGetRequest {
  string start_inclusive = 1;
  string end_exclusive = 2;
  bool include_payloads = 3;
}

message PutResponse {
  optional Stat stat = 1;
  Error error = 2;
}

message DeleteResponse {
  Error error = 2;
}

message GetResponse {
  bytes payload = 2;
  Stat stat = 3;
  Error error = 4;
}

message RangeDeleteResponse {
  repeated DeleteResponse delete = 1;
}

message RangeGetResponse {
  repeated GetResponse get = 1;
}

message NotificationRequest {
  fixed64 shard_id = 1;
  uint64 first_entry_id = 2;
  string key_prefix = 3;
  bool include_stat = 4;
}

message NotificationResponse {
  //TODO review the fields here
  fixed64 shard_id = 1;
  uint64 entry_id = 2;
  string key = 3;
  OperationType operation_type = 4;
  optional Stat stat = 5;
}

enum OperationType {
  INVALID = 0;
  PUT = 1;
  DELETE = 2;
}

message Stat {
  int64 version = 2;
  fixed64 created_timestamp = 3;
  fixed64 modified_timestamp = 4;
}

enum Error {
  NO_ERROR = 0;
  KEY_NOT_FOUND = 1;
  BAD_VERSION = 2;
}


/// TODO: This is for compatibility with existing

message PutOp {
  uint32 shard_id = 1;
  string key = 2;
  bytes payload = 3;
  optional uint64 expected_version = 4;
}

message GetOp {
  uint32 shard_id = 1;
  string key = 2;
}
