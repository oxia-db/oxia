syntax = "proto3";

package coordination;

option go_package = "github.com/streamnative/oxia/proto";

// controller -> node
service OxiaControl {
  rpc ShardAssignment(stream CoordinationShardAssignmentRequest) returns (stream CoordinationShardAssignmentResponse) {}

  rpc Fence(FenceRequest) returns (FenceResponse);
  rpc BecomeLeader(BecomeLeaderRequest) returns (BecomeLeaderResponse) {}
  rpc AddFollower(AddFollowerRequest) returns (CoordinationEmpty) {}

}

// node (leader) -> node (follower)
service OxiaLogReplication {
  rpc Truncate(TruncateRequest) returns (TruncateResponse) {}
  rpc AddEntries(stream AddEntryRequest) returns (stream AddEntryResponse) {}
}

message ServerAddress {
  string internal_url = 1;
  string public_url = 2;
}

message EntryId {
  uint64 epoch = 1;
  uint64 offset = 2;
}

message LogEntry {
  EntryId entry_id = 1;
  bytes value = 2;
  uint64 timestamp = 3;
}

message CoordinationEmpty {}

message FenceRequest {
  uint32 shard_id = 1;

  uint64 epoch = 2;
}
message FenceResponse {
  uint64 epoch = 1;
  EntryId head_index = 2;
}

message BecomeLeaderRequest {
  message FollowerEntry {
    ServerAddress key = 1;
    EntryId value = 2;
  }

  uint32 shard_id = 1;

  uint64 epoch = 2;
  uint32 replication_factor = 3;
  repeated FollowerEntry follower_maps = 4;
}

message BecomeLeaderResponse {
  uint64 epoch = 1;
}

message AddFollowerRequest {
  uint32 shard_id = 1;

  uint64 epoch = 2;
  ServerAddress follower = 3;
  EntryId head_index = 4;
}

message TruncateRequest {
  uint32 shard_id = 1;

  uint64 epoch = 2;
  EntryId head_index = 3;
  string source = 4;
}

message TruncateResponse {
  uint64 epoch = 1;
  EntryId head_index = 2;
}

message AddEntryRequest {
  uint64 epoch = 1;
  LogEntry entry = 2;
  EntryId commit_index = 3;
}
message AddEntryResponse {
  uint64 epoch = 1;
  EntryId entry_id = 2;
  bool invalid_epoch = 3;
}

// Shard assignment

message CoordinationShardAssignmentRequest {
  repeated CoordinationShardAssignment assignments = 1;
  CoordinationShardKeyRouter shard_key_router = 2;

}

message CoordinationShardAssignmentResponse {

}

/**
 * The assignment of a shard to a server.
 */
message CoordinationShardAssignment {
  // The shard id
  uint32 shard_id = 1;

  // The shard leader, e.g. `host:port`
  string leader = 2;

  // There could be multiple ways to describe the boundaries of a shard
  oneof shard_boundaries {
    CoordinationInt32HashRange int32_hash_range = 3;
  }
}

enum CoordinationShardKeyRouter {
  UNKNOWN = 0;

  XXHASH3 = 1;
}

/**
 * Represents a range of hash values [min, max)
 */
message CoordinationInt32HashRange {
  // The minimum inclusive hash that the shard can contain
  fixed32 min_hash_inclusive = 1;

  // The maximum exclusive hash that the shard can contain
  fixed32 max_hash_exclusive = 2;
}

